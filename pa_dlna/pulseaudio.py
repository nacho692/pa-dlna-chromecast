"""The pulseaudio interface."""

import asyncio
import logging
import re
import shutil
import time
from pathlib import Path

from libpulse.libpulse import (LibPulse, PA_SUBSCRIPTION_MASK_SINK_INPUT,
                               LibPulseError, LibPulseOperationError,
                               PA_INVALID_INDEX)
from .upnp.util import NL_INDENT, log_unhandled_exception

logger = logging.getLogger('pulse')

APPS_TITLE = 'Application name -> uuid'
APPS_HEADER = f"""# List of 'application name -> device uuid'.
#
# This list is generated by pa-dlna when run with the '--clients-uuids'
# command line option. You may remove a line or comment it out (using the '#'
# character as the line prefix) to remove the association between an
# application and a device.

# Default section header.
# DO NOT change the next line.
[{APPS_TITLE}]

"""


class MPRISMetadataProvider:
    """Optional metadata provider backed by playerctl and D-Bus.

    This helper is best-effort only: all errors are ignored so pa-dlna keeps
    running even when D-Bus is unavailable.
    """

    PLAYER_CACHE_TTL = 2.0

    def __init__(self):
        self.enabled = bool(shutil.which('playerctl') and shutil.which('gdbus'))
        self._players_cache_at = 0.0
        self._players_by_pid = {}

    async def _run_cmd(self, *args, timeout=0.5):
        proc = None
        try:
            proc = await asyncio.create_subprocess_exec(
                *args,
                stdin=asyncio.subprocess.DEVNULL,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.DEVNULL)
            out, _ = await asyncio.wait_for(proc.communicate(), timeout=timeout)
        except Exception:
            if proc is not None:
                try:
                    proc.kill()
                except Exception:
                    pass
            return ''
        if proc.returncode != 0:
            return ''
        return out.decode(errors='ignore').strip()

    async def _list_players(self):
        out = await self._run_cmd('playerctl', '--list-all')
        if not out:
            return []
        return [line.strip() for line in out.splitlines() if line.strip()]

    async def _pid_of_player(self, player):
        bus_name = f'org.mpris.MediaPlayer2.{player}'
        out = await self._run_cmd(
            'gdbus', 'call', '--session',
            '--dest', 'org.freedesktop.DBus',
            '--object-path', '/org/freedesktop/DBus',
            '--method', 'org.freedesktop.DBus.GetConnectionUnixProcessID',
            bus_name)
        if not out:
            return None
        match = re.search(r'(\d+)', out)
        if not match:
            return None
        try:
            return int(match.group(1))
        except ValueError:
            return None

    async def _players_by_pid_map(self):
        now = time.monotonic()
        if now - self._players_cache_at < self.PLAYER_CACHE_TTL:
            return self._players_by_pid

        players_by_pid = {}
        players = await self._list_players()
        for player in players:
            pid = await self._pid_of_player(player)
            if pid is not None:
                players_by_pid[pid] = player

        self._players_by_pid = players_by_pid
        self._players_cache_at = now
        return players_by_pid

    @staticmethod
    def _normalize(value):
        value = str(value or '').strip()
        if value.startswith('[') and value.endswith(']'):
            value = value[1:-1].strip().strip('"').strip("'")
        return value

    @staticmethod
    def _match_app_name(player, app_name):
        p = str(player or '').casefold()
        a = str(app_name or '').casefold()
        if not p or not a:
            return False
        return p == a or p.startswith(a + '.') or a in p

    @classmethod
    def _match_title_hint(cls, hint, title):
        h = cls._normalize(hint).casefold()
        t = cls._normalize(title).casefold()
        if not h or not t:
            return False
        if h == t:
            return True

        # Strip common "<title> - <app>" suffixes and compare again.
        h_short = h.split(' - ', 1)[0].strip()
        t_short = t.split(' - ', 1)[0].strip()
        if h_short and t_short and (h_short == t_short or
                                    h_short in t_short or
                                    t_short in h_short):
            return True

        # Last fallback: alphanumeric-only comparison to tolerate punctuation.
        h_alnum = re.sub(r'[^0-9a-z]+', '', h_short or h)
        t_alnum = re.sub(r'[^0-9a-z]+', '', t_short or t)
        if not h_alnum or not t_alnum:
            return False
        return (h_alnum == t_alnum or
                h_alnum in t_alnum or
                t_alnum in h_alnum)

    async def _metadata_for_player(self, player):
        fmt = ('{{xesam:title}}\t'
               '{{xesam:artist}}\t'
               '{{xesam:album}}\t'
               '{{mpris:artUrl}}')
        out = await self._run_cmd('playerctl', f'--player={player}',
                                  'metadata', '--format', fmt)
        if not out:
            return None
        fields = out.split('\t')
        while len(fields) < 4:
            fields.append('')
        title, artist, album, art_url = [self._normalize(v)
                                         for v in fields[:4]]
        if not any((title, artist, album, art_url)):
            return None
        return {'title': title,
                'artist': artist,
                'album': album,
                'art_url': art_url}

    async def metadata(self, pid=None, app_names=(), title_hint=''):
        if not self.enabled:
            return None

        player = None
        try:
            players = await self._list_players()
            if not players:
                return None

            if pid is not None:
                players_by_pid = await self._players_by_pid_map()
                player = players_by_pid.get(pid)

            if player is None:
                for app_name in app_names:
                    for name in players:
                        if self._match_app_name(name, app_name):
                            player = name
                            break
                    if player is not None:
                        break

            # Last resort: resolve the player by matching the active title.
            if player is None and title_hint:
                for name in players:
                    mdata = await self._metadata_for_player(name)
                    if mdata is None:
                        continue
                    if self._match_title_hint(title_hint,
                                              mdata.get('title', '')):
                        return mdata

            if player is None:
                return None

            return await self._metadata_for_player(player)
        except Exception:
            # Best effort only: silently ignore all failures.
            return None

    @staticmethod
    def _proplist_value(proplist, keys):
        for key in keys:
            value = proplist.get(key)
            if value is None:
                continue
            value = str(value).strip()
            if value:
                return value
        return ''

    @staticmethod
    def _int_value(value):
        if value is None:
            return None
        try:
            return int(str(value).strip())
        except Exception:
            return None

    async def enrich_proplist(self, proplist, client_proplist=None):
        if not self.enabled or not isinstance(proplist, dict):
            return False

        if not self.needs_enrichment(proplist):
            return False

        pid = self._int_value(self._proplist_value(
            proplist, ('application.process.id', 'application.pid')))
        title_hint = self._proplist_value(
            proplist, ('media.title', 'xesam:title', 'media.name'))
        app_names = [name for name in (
            self._proplist_value(proplist, ('application.name',)),
            self._proplist_value(proplist, ('application.process.binary',)))
            if name]

        if isinstance(client_proplist, dict):
            if pid is None:
                pid = self._int_value(self._proplist_value(
                    client_proplist, ('application.process.id',
                                      'application.pid')))
            for name in (
                    self._proplist_value(client_proplist, ('application.name',)),
                    self._proplist_value(client_proplist,
                                         ('application.process.binary',))):
                if name and name not in app_names:
                    app_names.append(name)

        mdata = await self.metadata(pid=pid, app_names=app_names,
                                    title_hint=title_hint)
        if not mdata:
            return False

        title = mdata.get('title', '')
        artist = mdata.get('artist', '')
        album = mdata.get('album', '')
        art_url = mdata.get('art_url', '')

        if title:
            proplist.setdefault('media.title', title)
            proplist.setdefault('xesam:title', title)
        if artist:
            proplist.setdefault('media.artist', artist)
            proplist.setdefault('xesam:artist', artist)
        if album:
            proplist.setdefault('xesam:album', album)
        if art_url:
            proplist.setdefault('mpris:artUrl', art_url)
            proplist.setdefault('xesam:artUrl', art_url)
        return True

    def needs_enrichment(self, proplist):
        if not isinstance(proplist, dict):
            return False
        have_title = bool(self._proplist_value(
            proplist, ('media.title', 'media.name', 'xesam:title')))
        have_artist = bool(self._proplist_value(
            proplist, ('media.artist', 'xesam:artist')))
        have_art = bool(self._proplist_value(
            proplist, ('mpris:artUrl', 'xesam:artUrl')))
        return not (have_title and have_artist and have_art)

# Classes.
class NullSink:
    """A connection between a sink_input and the null-sink of a Renderer.

    A NullSink is instantiated upon registering a Renderer instance.
    """

    def __init__(self, sink):
        self.sink = sink        # libpulse Sink instance
        self.sink_input = None  # libpulse SinkInput instance

class SinkInputEvent:
    def __init__(self, sink_input, event):
        self.type = event.type
        # 'sink' is the index of the sink associated with the sink-input.
        self.sink = sink_input.sink
        self.name = sink_input.name
        self.proplist = sink_input.proplist

    def __eq__(self, other):
        return (self.type == other.type and
                self.sink == other.sink and
                self.name == other.name and
                self.proplist == other.proplist)

class Pulse:
    """Pulse monitors pulseaudio sink-input events."""

    def __init__(self, av_control_point):
        self.av_control_point = av_control_point
        self.clients_uuids = av_control_point.clients_uuids
        self.applications = av_control_point.applications
        self.closing = False
        self.lib_pulse = None
        self.pa_dlna_clients_count = None
        self.sink_input_events = {}
        self.mpris = MPRISMetadataProvider()

    async def enrich_sink_input_metadata(self, sink_input):
        if not self.mpris.enabled:
            return False
        proplist = getattr(sink_input, 'proplist', None)
        if not isinstance(proplist, dict):
            return False

        needs_enrichment = self.mpris.needs_enrichment(proplist)
        client_proplist = None
        if needs_enrichment:
            client = await self.get_client(sink_input)
            client_proplist = getattr(client, 'proplist', None)
        enriched = await self.mpris.enrich_proplist(proplist, client_proplist)
        if enriched:
            art_url = proplist.get('mpris:artUrl') or proplist.get('xesam:artUrl')
            logger.debug(f"MPRIS metadata enriched for sink-input {sink_input.index}"
                         f" (art={'yes' if art_url else 'no'})")
        elif needs_enrichment:
            logger.debug(f'No MPRIS match for sink-input {sink_input.index}')
        return enriched

    async def close(self):
        if not self.closing:
            self.closing = True
            logger.info('Close pulse')
            await self.av_control_point.close()

    async def get_sink_by_module(self, renderer, module_index, module_name):
        """Get the sink matching a renderer from 'module_index'."""

        for sink in await self.lib_pulse.pa_context_get_sink_info_list():
            if sink.owner_module == module_index:
                logger.info(f'Load null-sink module {sink.name}'
                        f"{NL_INDENT}description='{renderer.description}'")

                # The module name is registered by pulseaudio after being
                # modified in pa_namereg_register() by replacing invalid
                # characters with '_'. The invalid characters are defined in
                # is_valid_char(char c).See the pulseaudio code.
                if len(module_name) != len(sink.name):
                    # Pulseaudio has added a '.n' suffix because there exists
                    # another null-sink with the same name.
                    await self.lib_pulse.pa_context_unload_module(module_index)

                    # AVControlPoint.abort() raises an exception.
                    renderer.control_point.abort(
                        f'Two DLNA devices registered with the same name:'
                        f'{NL_INDENT}{module_name}')

                return sink

    async def register(self, renderer):
        """Load a null-sink module."""

        if self.lib_pulse is None:
            return

        upnp_device = renderer.upnp_device
        module_name = f'{renderer.getattr("modelName")}-{upnp_device.UDN}'
        _description = renderer.description.replace(' ', r'\ ')

        module_index = await self.lib_pulse.pa_context_load_module(
                'module-null-sink',
                f'sink_name="{module_name}" '
                f'sink_properties=device.description=' f'"{_description}"')

        if module_index == PA_INVALID_INDEX:
            logger.error(f'Failed loading {module_name} pulseaudio module')
            return None

        sink = await self.get_sink_by_module(renderer, module_index,
                                                                module_name)
        if sink is None:
            await self.lib_pulse.pa_context_unload_module(module_index)
            logger.error(
                f'Failed getting sink of {module_name} pulseaudio module')
            return None

        return NullSink(sink)

    async def unregister(self, nullsink):
        if self.lib_pulse is None:
            return
        logger.info(f'Unload null-sink module {nullsink.sink.name}')
        await self.lib_pulse.pa_context_unload_module(
                                                nullsink.sink.owner_module)

    async def get_sink_input(self, renderer):
        assert renderer.nullsink is not None
        sink_inputs = (await
                       self.lib_pulse.pa_context_get_sink_input_info_list())
        for sink_input in sink_inputs:
            if sink_input.sink == renderer.nullsink.sink.index:
                return sink_input
        return None

    async def get_renderer_sink(self, renderer):
        if renderer is not None and renderer.nullsink.sink is not None:
            try:
                return await self.lib_pulse.pa_context_get_sink_info_by_name(
                                                renderer.nullsink.sink.name)
            except LibPulseOperationError as e:
                logger.warning(
                    f'Got exception at pulseaudio.get_renderer_sink(): {e!r}')

    def is_ignored_event(self, sink_input, event):
        index = event.index
        if index not in self.sink_input_events:
            self.sink_input_events[index] = SinkInputEvent(sink_input, event)
            return False
        else:
            if event.type == 'remove':
                del self.sink_input_events[index]
            else:
                last_event = self.sink_input_events[index]
                new_event = SinkInputEvent(sink_input, event)
                if new_event == last_event:
                    return True     # Ignore the event.
                else:
                    self.sink_input_events[index] = new_event
        return False

    def find_previous_renderer(self, event):
        """Find the renderer that was last connected to this sink-input."""

        for renderer in self.av_control_point.renderers():
            if (renderer.nullsink is not None and
                    renderer.nullsink.sink_input is not None and
                    renderer.nullsink.sink_input.index == event.index):
                return renderer

    async def find_renderer(self, event):
        """Find the renderer now connected to this sink-input."""

        notfound = (None, None)

        # Find the sink_input that has triggered the event.
        # Note that by the time this code is running, pulseaudio may have done
        # other changes. In other words, there may be inconsistencies between
        # the event and the sink_input and sink lists.
        sink_inputs = (await
                       self.lib_pulse.pa_context_get_sink_input_info_list())
        for sink_input in sink_inputs:
            if sink_input.index == event.index:
                # Ignore 'pulsesink probe' - seems to be used to query sink
                # formats (not for playback).
                if sink_input.name == 'pulsesink probe':
                    return notfound

                # Find the corresponding sink when it is the null-sink of a
                # Renderer.
                for renderer in self.av_control_point.renderers():
                    if (renderer.nullsink is not None and
                            renderer.nullsink.sink.index == sink_input.sink):
                        return renderer, sink_input
                break
        return notfound

    async def dispatch_event(self, event):
        """Dispatch the event to a renderer.

        event.type is either 'new', 'change' or 'remove'.
        A new event.index is generated by pulseaudio for each 'new' event. The
        index of a 'remove' event refers to the index of a previous 'new'
        event.

        A 'new' event establishes an association between a sink-input and
        a sink.

        IMPORTANT:
        'nullsink.sink' and 'nullsink.sink_input' are the renderer's instances
        built from one of the previous events. They are stale instances.
        'sink' and 'sink_input' returned by find_renderer() and
        get_sink_by_name() are the current instances as set by pulseaudio.
        """

        evt_type = event.type
        if evt_type == 'remove':
            renderer = self.find_previous_renderer(event)
            if renderer is not None:
                renderer.pulse_queue.put_nowait((evt_type, None, None))
            return

        renderer, sink_input = await self.find_renderer(event)
        if renderer is not None:
            assert sink_input is not None

            # Ignore sound settings events.
            # See src/pulse/proplist.h in Pulseaudio source code.
            proplist = sink_input.proplist
            if (proplist and 'media.role' in proplist and
                    proplist['media.role'] == 'event'):
                return

            # Optional MPRIS enrichment (best effort, silent failure).
            try:
                await self.enrich_sink_input_metadata(sink_input)
            except Exception:
                pass

            # 'renderer.nullsink.sink' is the stale sink from the previous
            # event, we need to fetch the 'sink' correponding to this event.
            sink = await self.get_renderer_sink(renderer)

            if sink is not None:
                if (self.is_ignored_event(sink_input, event) and
                        event.type not in ('new', 'remove')):
                    # Ignore a SinkInputEvent with no changes from the
                    # previous one (or if the previous one does not exist) and
                    # the event type is `change`.
                    pass
                elif sink_input.index == renderer.previous_idx:
                    # Ignore event related to the previous sink-input.
                    pass
                else:
                    renderer.pulse_queue.put_nowait(
                                                (evt_type, sink, sink_input))

        prev_renderer = self.find_previous_renderer(event)
        # The sink_input has been re-routed to another sink.
        if prev_renderer is not None and prev_renderer is not renderer:
            # Build our own 'exit' event (pulseaudio does not provide one)
            # for the sink that had been previously connected to this
            # sink_input.
            evt_type = 'exit'
            if event.index in self.sink_input_events:
                del self.sink_input_events[event.index]
            prev_renderer.pulse_queue.put_nowait((evt_type, None, None))

    def add_application(self, renderer, name, uuid):
        if self.applications is None:
            return
        if name not in self.applications or self.applications[name] != uuid:
            logger.info(f"Adding new association '{name}' ->"
                        f" uuid of '{renderer.name}'")
            self.applications[name] = uuid

    def write_applications(self):
        if not self.clients_uuids:
            return

        path = Path(self.clients_uuids)
        path = path.expanduser()
        try:
            with open(path, 'w') as f:
                f.write(APPS_HEADER)
                for k, val in self.applications.items():
                    indent = ' ' * max(20 - len(k), 1)
                    f.write(f'{k}{indent}-> {val}\n')
        except Exception as e:
            logger.exception(f'Error writing {path}: {e!r}')

    async def get_client(self, sink_input):
        if sink_input is not None:
            try:
                return await self.lib_pulse.pa_context_get_client_info(
                                                        sink_input.client)
            except LibPulseOperationError as e:
                logger.warning(
                        f'Got exception at pulseaudio.get_client(): {e!r}')

    async def move_sink_input(self, sink_input, sink):
        try:
            await self.lib_pulse.pa_context_move_sink_input_by_index(
                                                sink_input.index, sink.index)
            return sink_input
        except LibPulseOperationError as e:
            logger.warning(
                    f'Got exception at pulseaudio.move_sink_input(): {e!r}')

    async def find_sink_input(self, uuid):
        if self.applications is None:
            return
        lp = self.lib_pulse
        sink_inputs = await lp.pa_context_get_sink_input_info_list()
        for sink_input in sink_inputs:
            client = await self.get_client(sink_input)
            if client is None:
                continue
            app_name = client.proplist.get('application.name')
            if app_name is not None and self.applications.get(app_name) == uuid:
                return sink_input

    @log_unhandled_exception(logger)
    async def run(self):
        try:
            async with LibPulse('pa-dlna') as self.lib_pulse:
                # Only one instance of pa-dlna is allowed to run.
                self.pa_dlna_clients_count = len([client for client in
                        await self.lib_pulse.pa_context_get_client_info_list()
                                                if client.name == 'pa-dlna'])
                if self.pa_dlna_clients_count > 1:
                    logger.warning(
                        'There is already one instance of pa-dlna running')
                    return

                await self.lib_pulse.log_server_info()

                # Start the iteration on sink-input events.
                await self.lib_pulse.pa_context_subscribe(
                                    PA_SUBSCRIPTION_MASK_SINK_INPUT)
                iterator = self.lib_pulse.get_events_iterator()
                self.av_control_point.start_event.set()
                async for event in iterator:
                    await self.dispatch_event(event)

                # Wait until end of test.
                test_end = getattr(self.av_control_point, 'test_end', None)
                if test_end is not None:
                    await test_end

        except LibPulseError as e:
            logger.error(f'{e!r}')
        finally:
            self.write_applications()
            self.lib_pulse = None
            await self.close()
